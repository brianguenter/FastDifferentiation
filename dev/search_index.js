var documenterSearchIndex = {"docs":
[{"location":"futurework/#Future-Work","page":"Future work","title":"Future Work","text":"","category":"section"},{"location":"futurework/","page":"Future work","title":"Future work","text":"The two biggest limitations of FD are no support for conditionals involving FD variables and code size that scales with number of operations. ","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"The first can be dealt with by modifying make_function. The new generated code would have three distinct steps:","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"Evaluate conditionals that involve FD variables and generate a bit vector of the boolean values.\nIndex into a dictionary with the bit vector to see if this combination of conditionals has been seen before. If it has use the previously generated executable.\nIf necessary generate a new executable where the conditional values are all known. Generate the new expression graph and compute and complile the derivative code and cache it.","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"The size of the dictionary can be allowed to grow arbitrarily or an LRU type scheme can be used to discard the least recently used executable from the cahce.","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"If the set of conditials has good temporal locality then it shouldn't be necessary to recompile very often. The amortized cost should be good.","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"When expression graphs get larger than about 10^5 nodes LLVM compilation time rises rapidly and can be extremely long. Large programs cannot fit in the smallest and fastest caches, so performance will be limited by cache memory bandwidth, because each instruction is executed only once. In the worst case the runtime generated function wouldn't even fit in the L3 cache and performance would be limited by main memory bandwidth.","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"A method for dealing with excessive code size is loop rerolling. FD essentially unrolls all loops so vector operations become scalar operations. It should be possible to recognize certain common patterns of unrolling and to undo them. Undoing the unrolling all the way back to the original source expression isn't necessary so long as the code size can be substantially reduced.","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"The most common pattern that causes code expansion is tensor contraction, which occurs in matrix-vector and matrix-matrix operations. These patterns are simple and should be easily recognized and rerolled. The original expression graph can be annotated with metadata that makes rerolling easier. For example:","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"julia> A = make_variables(:a,2,2)\n2×2 Matrix{FastDifferentiation.Node}:\n a1_1  a1_2\n a2_1  a2_2\n\njulia> b = make_variables(:b,2)\n2-element Vector{FastDifferentiation.Node}:\n b1\n b2\n\njulia> jacobian(cos.(A*b),vcat(vec(A),b))\n2×6 Matrix{FastDifferentiation.Node}:\n (-(sin(((a1_1 * b1) + (a1_2 * b2)))) * b1)                                         0.0  …  (-(sin(((a1_1 * b1) + (a1_2 * b2)))) * a1_2)\n                                        0.0  (-(sin(((a2_1 * b1) + (a2_2 * b2)))) * b1)     (-(sin(((a2_1 * b1) + (a2_2 * b2)))) * a2_2)\n\njulia> A\n2×2 Matrix{FastDifferentiation.Node}:\n a1_1  a1_2\n a2_1  a2_2\n\njulia> b\n2-element Vector{FastDifferentiation.Node}:\n b1\n b2\n\njulia> A*b\n2-element Vector{Any}:\n ((a1_1 * b1) + (a1_2 * b2))\n ((a2_1 * b1) + (a2_2 * b2))\n\njulia> cos.(A*b)\n2-element Vector{FastDifferentiation.Node{typeof(cos), 1}}:\n cos(((a1_1 * b1) + (a1_2 * b2)))\n cos(((a2_1 * b1) + (a2_2 * b2)))\n\njulia> jacobian(ans,vcat(vec(A),b))\n2×6 Matrix{FastDifferentiation.Node}:\n (-(sin(((a1_1 * b1) + (a1_2 * b2)))) * b1)  0.0                      …                     (-(sin(((a1_1 * b1) + (a1_2 * b2)))) * a1_2)\n0.0                                         (-(sin(((a2_1 * b1) + (a2_2 * b2)))) * b1)      (-(sin(((a2_1 * b1) + (a2_2 * b2)))) * a2_2)","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"Because the variable indices are carried in the variable names it should be relatively easy to spot tensor contraction sequences like this (a1_1 * b1) + (a1_2 * b2)) and replace them with a tensor contraction operator on matrix elements.","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"Another possibility is to use DynamicExpressions.jl instead of LLVM compilation of large runtime generated programs. When graph size goes above 10^5 nodes LLVM compilation time can increase dramatically, but DynamicExpressions can be quite fast at even larger scales and have reasonable performance. This would be especially useful when the function is changing frequently so compilation overhead cannot be amortized across many derivative evaluations.","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"Some hybrid of loop rerolling and DynamicExpressions may make it possible to scale FD to expressions several orders of magnitude larger than the current practical limit.","category":"page"},{"location":"futurework/","page":"Future work","title":"Future work","text":"In the short term reducing memory allocations during the derivative computation stage should substantially improve performance.","category":"page"},{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"See Benchmarks.jl for the benchmark code used to generate these results.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks test the speed of gradients, Jacobians, Hessians, and the ability to exploit sparsity in the derivative. The last problem, ODE, also compares the AD algorithms to a hand optimized Jacobian. There are not many benchmarks so take these results with a grain of salt; they may be useful for order of magnitude comparisons but not much more. Also, two of these packages, FastDifferentiation and Enzyme, are under active development. These benchmarks could change materially in the near future.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"I am not an expert in any of these packages except for FD. For some of the benchmarks I have not yet figured out how to correctly and efficiently compute all the derivatives. I am indebted to Yingbo Ma and Billy Moses for their help debugging and improving the benchmark code for ForwardDiff and Enzyme, respectively. ","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Several of the AD algorithms have unexpectedly slow timings; the Enzyme Rosenbrock Hessian timings are notable in this respect since for the other benchmarks Enzyme has excellent performance. Perhaps these codes can be rewritten to be more efficient. If you are expert in any of these packages please submit a PR to fix, improve, or correct a benchmark.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"When determining which AD algorithm to use keep in mind the limitations of FD: operation count and conditionals. The total operation count of your expression should be less than 10⁵. You may get reasonable performance for expressions as large as 10⁶ operations but expect very long compile times. FD does not support conditionals which involve the differentiation variables (yet). The other algorithms do not have these limitations.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"To generate the markdown for the results in this section execute the function write_markdown() in the file Benchmarks.jl at the Benchmarks.jl repo.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"These timings are just for evaluating the derivative function. They do not include preprocessing time required to generate and compile the function nor any time needed to generate auxiliary data structures that make the evaluation more efficient.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The times in each row are normalized to the shortest time in that row. The fastest algorithm will have a relative time of 1.0 and all other algorithms will have a time ≥ 1.0. Smaller numbers are better.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"All benchmarks run on this system:","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Julia Version 1.9.2\nCommit e4ee485e90 (2023-07-05 09:39 UTC)\nPlatform Info:\n  OS: Windows (x86_64-w64-mingw32)\n  CPU: 32 × AMD Ryzen 9 7950X 16-Core Processor            \n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-14.0.6 (ORCJIT, znver3)\n  Threads: 1 on 32 virtual cores\nEnvironment:\n  JULIA_EDITOR = code.cmd","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Function FD sparse FD dense ForwardDiff ReverseDiff Enzyme Zygote\nRosenbrock Hessian 1.00 8.31 33455.33 99042.70 194.5 85003.60\nRosenbrock gradient [1] 1.29 674.82 299.67 1.00 4208.30\nSimple matrix Jacobian [1] 1.00 34.09 51.25 [50] 125.26\nSpherical harmonics Jacobian [1] 1.00 29.25 [40] [51] [6]","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[1]: FD sparse was slower than FD dense so results are only shown for dense.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[1]: FD sparse was slower than FD dense so results are only shown for dense.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[50]: Enzyme prints \"Warning: using fallback BLAS replacements, performance may be degraded\", followed by stack overflow error or endless loop.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[1]: FD sparse was slower than FD dense so results are only shown for dense.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[40]: ReverseDiff failed on Spherical harmonics.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[51]: Enzyme crashes Julia REPL for SHFunctions benchmark.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"[6]: Zygote doesn't work with Memoize","category":"page"},{"location":"benchmarks/#Comparison-to-hand-optimized-Jacobian.","page":"Benchmarks","title":"Comparison to hand optimized Jacobian.","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This compares AD algorithms to a hand optimized Jacobian (in file ODE.jl). As before timings are relative to the fastest time. Enzyme (array) is written to accept a vector input and return a matrix output to be compatible with the calling convention for the ODE function. This is very slow because Enzyme does not yet do full optimizations on these input/output types. Enzyme (tuple) is written to accept a tuple input and returns tuple(tuples). This is much faster but not compatible with the calling convetions of the ODE function. This version uses features not avaialable in the registered version of Enzyme (as of 7-9-2023). You will need to ] add Enzyme#main instead of using the registered version.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"FD sparse FD Dense ForwardDiff ReverseDiff Enzyme (array) Enzyme (tuple) Zygote Hand optimized\n1.00 1.83 32.72 [41] 281.05 4.30 554767.55 2.50","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"It is worth nothing that both FD sparse and FD dense are faster than the hand optimized Jacobian. [41]: ODE not implemented for ReverseDiff","category":"page"},{"location":"benchmarks/#Rate-of-growth-of-Jacobian","page":"Benchmarks","title":"Rate of growth of Jacobian","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"It is also intersting to note the ratio of the number of operations of the FD Jacobian of a function to the number of operations in the original function. ","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Problem sizes in approximately the ratio 1 \\:10 \\: 100 \\: 1000 were computed for several of the benchmarks.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The ratio (jacobian operations)/(original function operations) stays close to a constant over 2 orders of magnitude of problem size for Rosenbrock and Spherical harmonics. For the simple matrix ops Jacobian the ratio goes from 2.6 to 6.5 over 3 orders of magnitude of problem size. The ratio is growing far more slowly than the domain and codomain dimensions of the problem: the smallest instance is an R⁸->R⁴ function and the largest is R⁸⁰⁰->R⁴⁰⁰ an increase in both domain and codomain dimensions of 100x.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Relative problem size Rosenbrock Jacobian Spherical harmonics Jacobian Simple matrix ops Jacobian\n1x 1.13 2.2 2.6\n10x 1.13 2.34 3.5\n100x 1.13 2.4 3.8\n1000x   6.5","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"This is a very small sample of functions but it will be interesting to see if this slow growth of the Jacobian with increasing domain and codomain dimensions generalizes to all functions or only applies to functions with special graph structure.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [FastDifferentiation]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"api/#FastDifferentiation.clear_cache-Tuple{}","page":"API","title":"FastDifferentiation.clear_cache","text":"Clears the global expression cache. To maximize efficiency of expressions the differentation system automatically eliminates common subexpressions by checking for their existence in the global expression cache. Over time this cache can become arbitrarily large. Best practice is to clear the cache before you start defining expressions, define your expressions and then clear the cache.\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.derivative-Union{Tuple{T}, Tuple{AbstractArray{<:FastDifferentiation.Node}, Vararg{T}}} where T<:FastDifferentiation.Node","page":"API","title":"FastDifferentiation.derivative","text":"computes ∂A/(∂variables[1],...,∂variables[n]). Repeated differentiation rather than computing different columns of the Jacobian. Example:\n\n\njulia> A = [t t^2;3t^2 5]  \n2×2 Matrix{Node}:\n t              (t ^ 2)\n (3 * (t ^ 2))  5\n\njulia> derivative(A,t)  \n2×2 Matrix{Node}:\n 1.0      (2 * t)\n (6 * t)  0.0\n\njulia> derivative(A,t,t)  \n2×2 Matrix{Node{T, 0} where T}:\n 0.0  2\n 6    0.0\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.differential-Tuple{Vararg{FastDifferentiation.Node}}","page":"API","title":"FastDifferentiation.differential","text":"Returns an anonymous function that takes the derivative of a scalar function with respect to variables. Example:\n\njulia> @variables t\nt\n\njulia> f = t^2\n(t ^ 2)\n\njulia> Dt = differential(t)      \n#69 (generic function with 1 method)\n\njulia> Dt(f)\n(2 * t)\n\njulia> Dt = differential(t,t)    \n#69 (generic function with 1 method)\n\njulia> Dt(f)\n2\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.hessian-Union{Tuple{S}, Tuple{FastDifferentiation.Node, AbstractVector{S}}} where S<:FastDifferentiation.Node","page":"API","title":"FastDifferentiation.hessian","text":"Returns the dense symbolic Hessian matrix. Example:\n\njulia> @variables x y\n\njulia> hessian(x^2*y^2,[x,y])\n2×2 Matrix{FastDifferentiation.Node}:\n (2 * (y ^ 2))  (4 * (y * x))\n (4 * (x * y))  (2 * (x ^ 2))\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.hessian_times_v-Union{Tuple{S}, Tuple{T}, Tuple{T, AbstractVector{S}}} where {T<:FastDifferentiation.Node, S<:FastDifferentiation.Node}","page":"API","title":"FastDifferentiation.hessian_times_v","text":"Computes Hessian times a vector v without forming the Hessian matrix. Useful when the Hessian would be impractically large.\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.jacobian-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T<:FastDifferentiation.Node, S<:FastDifferentiation.Node}","page":"API","title":"FastDifferentiation.jacobian","text":"Jacobian matrix of the n element function defined by terms. Each term element is a Node expression graph. Only the columns of the Jacobian corresponsing to the elements of partial_variables will be computed and the partial columns in the Jacobian matrix will be in the order specified by partial_variables. Examples:\n\n\njulia> @variables x y\n\njulia> jacobian([x*y,y*x],[x,y])\n2×2 Matrix{Node}:\n y  x\n y  x\n\njulia> jacobian([x*y,y*x],[y,x])\n2×2 Matrix{Node}:\n x  y\n x  y\n\njulia> jacobian([x*y,y*x],[x])\n2×1 Matrix{Node}:\n y\n y\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.jacobian_times_v-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T<:FastDifferentiation.Node, S<:FastDifferentiation.Node}","page":"API","title":"FastDifferentiation.jacobian_times_v","text":"Returns a vector of Node, where each element in the vector is the symbolic form of Jv. Also returnsv_vectora vector of thevvariables. This is useful if you want to generate a function to evaluateJvand you want to separate the inputs to the function and thev` variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.jacobian_transpose_v-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T<:FastDifferentiation.Node, S<:FastDifferentiation.Node}","page":"API","title":"FastDifferentiation.jacobian_transpose_v","text":"Returns a vector of Node, where each element in the vector is the symbolic form of Jᵀv. Also returns v_vector a vector of the v variables. This is useful if you want to generate a function to evaluate Jᵀv and you want to separate the inputs to the function and the v variables.\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.make_function-Union{Tuple{T}, Tuple{AbstractArray{T}, Vararg{AbstractVector{<:FastDifferentiation.Node}}}} where T<:FastDifferentiation.Node","page":"API","title":"FastDifferentiation.make_function","text":"Makes a function to evaluate the symbolic expressions in func_array. If in_place=true it will generate code to fill a user supplied array with the result. In this case if an element of func_array is identically zero the generated code will not set the result to zero to zero because this leads to code bloat and slow execution. If you need these array elements to be zero instead of undef you should properly initialize your array to zero before passing it to the runtime generated function.\n\nIf in_place=false then the returned array will be properly initialized with zeros.\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.make_variables-Union{Tuple{T}, Tuple{Symbol, Vararg{T}}} where T","page":"API","title":"FastDifferentiation.make_variables","text":"Returns an Array of variables with names corresponding to their indices in the Array. Example: ```julia julia> make_variables(:x,3) 3-element Vector{FastDifferentiation.Node}:  x1  x2  x3\n\njulia> makevariables(:x,2,3) 2×3 Matrix{FastDifferentiation.Node}:  x11  x12  x13  x21  x22  x2_3\n\njulia> makevariables(:x,2,3,2) 2×3×2 Array{FastDifferentiation.Node, 3}: [:, :, 1] =  x111  x121  x131  x211  x221  x23_1\n\n[:, :, 2] =  x112  x122  x132  x212  x222  x232  ```\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.sparse_hessian-Union{Tuple{S}, Tuple{FastDifferentiation.Node, AbstractVector{S}}} where S<:FastDifferentiation.Node","page":"API","title":"FastDifferentiation.sparse_hessian","text":"Compute a sparse symbolic Hessian. Returns a sparse matrix of symbolic expressions.  Can be used in combination with make_function to generate an executable that  will return a sparse matrix or take one as an in-place argument. Example:\n\njulia> @variables x y\n\njulia> a = sparse_hessian(x*y,[x,y])\n2×2 SparseArrays.SparseMatrixCSC{FastDifferentiation.Node, Int64} with 2 stored entries:\n ⋅  1\n 1  ⋅\n\njulia> f1 = make_function(a,[x,y])\n...\n\njulia> f1([1.0,2.0])\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n  ⋅   1.0\n 1.0   ⋅\n\njulia> tmp = similar(a,Float64)\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n  ⋅            4.24399e-314\n 4.24399e-314   ⋅\n\njulia> f2 = make_function(a,[x,y],in_place=true)\n...\n\njulia> f2([1.0,2.0],tmp)\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n  ⋅   1.0\n 1.0   ⋅\n\njulia> tmp\n2×2 SparseArrays.SparseMatrixCSC{Float64, Int64} with 2 stored entries:\n  ⋅   1.0\n 1.0   ⋅\n\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.sparse_jacobian-Union{Tuple{S}, Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{S}}} where {T<:FastDifferentiation.Node, S<:FastDifferentiation.Node}","page":"API","title":"FastDifferentiation.sparse_jacobian","text":"Returns a sparse array containing the Jacobian of the function defined by terms\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.sparsity-Tuple{AbstractArray{<:FastDifferentiation.Node}}","page":"API","title":"FastDifferentiation.sparsity","text":"Used to determine whether to fill zero array elements with an assignment statement or to fill the array in the declaration. Function arrays with many zero elements generate many zero assignment statements which can make compilation time slow. But Need a heuristic to determine when to choose one or the other.\n\n\n\n\n\n","category":"method"},{"location":"api/#FastDifferentiation.sparsity-Tuple{FastDifferentiation.DerivativeGraph}","page":"API","title":"FastDifferentiation.sparsity","text":"Computes sparsity of Jacobian matrix = nonzeroentries/total_entries.\n\n\n\n\n\n","category":"method"},{"location":"symbolicprocessing/#Symbolic-Processing","page":"Symbolic processing","title":"Symbolic Processing","text":"","category":"section"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"Because FD can generate true symbolic derivatives it can easily be used in conjunction with Symbolics.jl using the package FDConversion.jl (still under development).","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"A rule of thumb is that if your function is small (a few hundred operations or less) or tree like (where each node in the expression graph has one parent on average) then Symbolics.jl may outperform or equal FD. For more complex functions with many common subexpressions FD may substantially outperform Symbolics.jl.","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"Take these benchmarks with a large grain of salt since there are so few of them. Whether your function will have this kind of performance improvement relative to Symbolics.jl is hard to predict until the benchmark set gets much bigger.","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"These benchmarks should give you a sense of what performance you might achieve for symbolic processing. There are three types of benchmarks: Symbolic, MakeFunction, and Exe.","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"The Symbolic benchmark is the time required to compute just the symbolic form of the derivative. The Symbolic benchmark can be run with simplification turned on or off for Symbolics.jl. If simplification is on then computation time can be extremely long but the resulting expression might be simpler and faster to execute.\nThe MakeFunction benchmark is the time to generate a Julia Expr from an already computed symbolic derivative and to then compile it.\nThe Exe benchmark measures just the time required to execute the compiled function using an in-place matrix.","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"All benchmarks show the ratio of time taken by Symbolics.jl to FastDifferentiation.jl. Numbers greater than 1 mean FastDifferentiation is faster.","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"All benchmarks were run on an AMD Ryzen 9 7950X 16-Core Processor with 32GB RAM running Windows 11 OS, Julia version 1.9.0.","category":"page"},{"location":"symbolicprocessing/#Chebyshev-polynomial","page":"Symbolic processing","title":"Chebyshev polynomial","text":"","category":"section"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"The first example is a recursive function for  the Chebyshev polynomial of order n:","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"@memoize function Chebyshev(n, x)\n    if n == 0\n        return 1\n    elseif n == 1\n        return x\n    else\n        return 2 * (x) * Chebyshev(n - 1, x) - Chebyshev(n - 2, x)\n    end\nend","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"The function is memoized so the recursion executes efficiently. ","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"The recursive function returns an nth order polynomial in the variable x. The derivative of this polynomial would be order n-1 so a perfect symbolic simplification would result in a function with 2*(n-2) operations. For small values of n Symbolics.jl simplification does fairly well but larger values result in very inefficient expressions.","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"Because FD doesn't do sophisticated symbolic simplification it generates a derivative with approximately 2.4x the number of operations in the original recursive expression regardless of n. This is a case where a good hand generated derivative would be more efficient than FD.","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"The Chebyshev expression graph does not have many nodes even at the largest size tested (graph size increases linearly with Chebyshev order).","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"The first set of three benchmarks show results with simplification turned off in Symbolics.jl, followed by a set of three with simplification turned on. Performance is somewhat better in the latter case but still slower than the FD executable. Note that the y axis is logarithmic.","category":"page"},{"location":"symbolicprocessing/#Chebyshev-benchmarks-with-simplification-off","page":"Symbolic processing","title":"Chebyshev benchmarks with simplification off","text":"","category":"section"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"(Image: Symbolic processing, simplify=false)  (Image: MakeFunction, simplify=false)  (Image: Exe, simplify=false)","category":"page"},{"location":"symbolicprocessing/#Chebyshev-benchmarks-with-simplification-on","page":"Symbolic processing","title":"Chebyshev benchmarks with simplification on","text":"","category":"section"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"(Image: MakeFunction, simplify=false)","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"With simplification on performance of the executable derivative function for Symbolics.jl is slightly better than with simplification off. But simplification processing time is longer.","category":"page"},{"location":"symbolicprocessing/#Spherical-Harmonics","page":"Symbolic processing","title":"Spherical Harmonics","text":"","category":"section"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"The second example is the spherical harmonics function. This is the expression graph for the spherical harmonic function of order 8: (Image: MakeFunction, simplify=false)","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"@memoize function P(l, m, z)\n    if l == 0 && m == 0\n        return 1.0\n    elseif l == m\n        return (1 - 2m) * P(m - 1, m - 1, z)\n    elseif l == m + 1\n        return (2m + 1) * z * P(m, m, z)\n    else\n        return ((2l - 1) / (l - m) * z * P(l - 1, m, z) - (l + m - 1) / (l - m) * P(l - 2, m, z))\n    end\nend\nexport P\n\n@memoize function S(m, x, y)\n    if m == 0\n        return 0\n    else\n        return x * C(m - 1, x, y) - y * S(m - 1, x, y)\n    end\nend\nexport S\n\n@memoize function C(m, x, y)\n    if m == 0\n        return 1\n    else\n        return x * S(m - 1, x, y) + y * C(m - 1, x, y)\n    end\nend\nexport C\n\nfunction factorial_approximation(x)\n    local n1 = x\n    sqrt(2 * π * n1) * (n1 / ℯ * sqrt(n1 * sinh(1 / n1) + 1 / (810 * n1^6)))^n1\nend\nexport factorial_approximation\n\nfunction compare_factorial_approximation()\n    for n in 1:30\n        println(\"n $n relative error $((factorial(big(n))-factorial_approximation(n))/factorial(big(n)))\")\n    end\nend\nexport compare_factorial_approximation\n\n@memoize function N(l, m)\n    @assert m >= 0\n    if m == 0\n        return sqrt((2l + 1 / (4π)))\n    else\n        # return sqrt((2l+1)/2π * factorial(big(l-m))/factorial(big(l+m)))\n        #use factorial_approximation instead of factorial because the latter does not use Stirlings approximation for large n. Get error for n > 2 unless using BigInt but if use BigInt get lots of rational numbers in symbolic result.\n        return sqrt((2l + 1) / 2π * factorial_approximation(l - m) / factorial_approximation(l + m))\n    end\nend\nexport N\n\n\"\"\"l is the order of the spherical harmonic\"\"\"\n@memoize function Y(l, m, x, y, z)\n    @assert l >= 0\n    @assert abs(m) <= l\n    if m < 0\n        return N(l, abs(m)) * P(l, abs(m), z) * S(abs(m), x, y)\n    else\n        return N(l, m) * P(l, m, z) * C(m, x, y)\n    end\nend\nexport Y\n\nSHFunctions(max_l, x::Node, y::Node, z::Node) = SHFunctions(Vector{Node}(undef, 0), max_l, x, y, z)\nSHFunctions(max_l, x::Symbolics.Num, y::Symbolics.Num, z::Symbolics.Num) = SHFunctions(Vector{Symbolics.Num}(undef, 0), max_l, x, y, z)\n\nfunction SHFunctions(shfunc, max_l, x, y, z)\n    for l in 0:max_l-1\n        for m in -l:l\n            push!(shfunc, Y(l, m, x, y, z))\n        end\n    end\n\n    return shfunc\nend\nexport SHFunctions\n\nfunction spherical_harmonics(::JuliaSymbolics, model_size)\n    Symbolics.@variables x y z\n    return SHFunctions(model_size, x, y, z), [x, y, z]\nend\n\nfunction spherical_harmonics(::FastSymbolic, model_size, x, y, z)\n    graph = DerivativeGraph(SHFunctions(model_size, x, y, z))\n    return graph\nend\n\nfunction spherical_harmonics(package::FastSymbolic, model_size)\n    FD.@variables x, y, z\n    return spherical_harmonics(package, model_size, x, y, z)\nend\nexport spherical_harmonics","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"As was the case for Chebyshev polynomials the number of paths from the roots to the variables is much greater than the number of nodes in the graph. Once again the y axis is logarithmic.","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"(Image: Symbolic processing, simplify=false) (Image: MakeFunction, simplify=false) (Image: Exe, simplify=false)","category":"page"},{"location":"symbolicprocessing/","page":"Symbolic processing","title":"Symbolic processing","text":"The Exe benchmark took many hours to run and was stopped at model size 24 instead of 25 as for the Symbolic and MakeFunction benchmarks.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"FD uses a global cache for common subexpression elimination so the FD symbolics preprocessing step is not thread safe. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Under ordinary conditions the memory used by the cache won't be an issue. But, if you have a long session where you are creating many complex functions it is possible the cache will use too much memory. If this happens call the function clear_cache after you have completely processed your expression.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The most common way to use FD is this:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"create variables\ndo operations on those variables to create the function you want to differentiate\ncompute a symbolic derivative of the function\npass the symbolic derivative to make_function to generate a function to efficiently evaluate the derivative","category":"page"},{"location":"examples/#Creating-Variables","page":"Examples","title":"Creating Variables","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Scalar variables","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using FastDifferentiation\n\n@variables x y z\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Arrays of variables of arbitrary dimension","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> make_variables(:x,3)\n3-element Vector{FastDifferentiation.Node}:\n x1\n x2\n x3\n\njulia> make_variables(:x,2,3)\n2×3 Matrix{FastDifferentiation.Node}:\n x1_1  x1_2  x1_3\n x2_1  x2_2  x2_3\n\njulia> make_variables(:x,2,3,2)\n2×3×2 Array{FastDifferentiation.Node, 3}:\n[:, :, 1] =\n x1_1_1  x1_2_1  x1_3_1\n x2_1_1  x2_2_1  x2_3_1\n\n[:, :, 2] =\n x1_1_2  x1_2_2  x1_3_2\n x2_1_2  x2_2_2  x2_3_2","category":"page"},{"location":"examples/#Compute-derivatives","page":"Examples","title":"Compute derivatives","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Compute higher order derivatives","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> @variables x y\ny\n\njulia> f = x^3*y^3\n((x ^ 3) * (y ^ 3))\n\njulia> derivative([f],x,y,x) #take derivative wrt x, then y, then x\n1-element Vector{FastDifferentiation.Node{typeof(*), 2}}:\n (18 * (x * (y ^ 2)))\n\n julia> derivative([cos(x*y);;;exp(x*y)],x,y,x) #derivative accepts input arrays of any dimension\n1×1×2 Array{FastDifferentiation.Node{typeof(+), 2}, 3}:\n[:, :, 1] =\n ((-(y) * cos((x * y))) + ((((x * -(y)) * -(sin((x * y)))) + -(cos((x * y)))) * y))\n\n[:, :, 2] =\n (((((x * y) + 1) * exp((x * y))) * y) + (y * exp((x * y))))\n ```\n\nCompute derivative of a function and make executable\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia","category":"page"},{"location":"examples/#compute-Jacobian-and-generate-function-to-evaluate-it","page":"Examples","title":"compute Jacobian and generate function to evaluate it","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f1 = cos(x) * y (cos(x) * y)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f2 = sin(y) * x (sin(y) * x)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> symb = jacobian([f1, f2], [x, y]) #the vector [x,y] tells make_function ","category":"page"},{"location":"examples/#how-to-order-the-arguments-to-the-generated-function","page":"Examples","title":"how to order the arguments to the generated function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"2×2 Matrix{Node}:  (y * -(sin(x)))  cos(x)  sin(y)           (x * cos(y))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jacexe = makefunction(symb,[x,y])  ... julia> jacexe([1.0,2.0]) #jacexe was created with variable ordering [x,y] ","category":"page"},{"location":"examples/#so-x-will-get-the-value-1.0,-y-2.0","page":"Examples","title":"so x will get the value 1.0, y 2.0","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"2×2 Matrix{Float64}:  -1.68294    0.540302   0.909297  -0.416147","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia","category":"page"},{"location":"examples/#compute-Hessian-and-generate-function-to-evaluate-it","page":"Examples","title":"compute Hessian and generate function to evaluate it","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"@variables x y z","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> h_symb1 = hessian(x^2y^2z^2,[x,y,z]) 3×3 Matrix{FastDifferentiation.Node}:  (2 * ((z ^ 2) * (y ^ 2)))        (((2 * x) * (2 * y)) * (z ^ 2))  (((2 * x) * (2 * z)) * (y ^ 2))  (((2 * y) * (2 * x)) * (z ^ 2))  (2 * ((z ^ 2) * (x ^ 2)))        (((2 * y) * (2 * z)) * (x ^ 2))  (((2 * z) * (2 * x)) * (y ^ 2))  (((2 * z) * (2 * y)) * (x ^ 2))  (2 * ((x ^ 2) * (y ^ 2)))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> hexe1 = makefunction(hsymb1,[x,y,z]) #the vector [x,y,z] tells makefunction ","category":"page"},{"location":"examples/#how-to-order-the-arguments-to-the-generated-function-2","page":"Examples","title":"how to order the arguments to the generated function","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"... julia> hexe1([1.0,2.0,3.0]) #hexe1 was created with variable ordering [x,y,z] ","category":"page"},{"location":"examples/#so-x-will-get-the-value-1.0,-y-2.0,-and-z-3.0","page":"Examples","title":"so x will get the value 1.0, y 2.0, and z 3.0","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"3×3 Matrix{Float64}:  72.0  72.0  48.0  72.0  18.0  24.0  48.0  24.0   8.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n\nCompute any subset of the columns of the Jacobian:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia julia> symb = jacobian([xy,yz,x*z],[x,y,z]) #all columns 3×3 Matrix{Node}:  y    x    0.0  0.0  z    y  z    0.0  x","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> symb = jacobian([xy,yz,x*z],[x,y]) #first two columns 3×2 Matrix{Node}:  y    x  0.0  z  z    0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> symb = jacobian([xy,yz,x*z],[z,y]) #second and third columns, ordered so ∂f/∂z is 1st column of the output, ∂f/∂y the 2nd 3×2 Matrix{Node}:  0.0  x  y    z  x    0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"##### More on make_function\nSometimes you want to evaluate a function and one or more derivative orders. If you pack all the terms you want to evaluate into the argument to `make_function` then common terms will be detected and only computed once. This will be generally be more efficient than evaluating the function and derivatives separately:\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia julia> f = [x^2y^2,sqrt(xy)] 2-element Vector{FastDifferentiation.Node}:  ((x ^ 2) * (y ^ 2))        sqrt((x * y))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jac = jacobian(f,[x,y]) 2×2 Matrix{FastDifferentiation.Node}:              ((y ^ 2) * (2 * x))              ((x ^ 2) * (2 * y))  ((1 / (2 * sqrt((x * y)))) * y)  ((1 / (2 * sqrt((x * y)))) * x)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> fandjac = make_function([vec(jac);f],[x,y]) ...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> tmp = fandjac([1.1,2.1]) 6-element Vector{Float64}:  9.702000000000002  0.6908492797077573  5.082000000000001  0.36187343222787294  5.336100000000001  1.5198684153570665","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jac_eval = reshape(view(tmp,1:4),2,2) 2×2 reshape(view(::Vector{Float64}, 1:4), 2, 2) with eltype Float64:  9.702     5.082  0.690849  0.361873","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f_eval = view(tmp,5:6) 2-element view(::Vector{Float64}, 5:6) with eltype Float64:  5.336100000000001  1.5198684153570665","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nThere are several options for `make_function`. If `in_place==false`, the default, then it will create and return a new matrix at each function call. If `in_place==true` it will make a function that expects two arguments, a vector of input variable values and a matrix to hold the result. The `in_place` option is available on all executables including Jᵀv,Jv,Hv.\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia julia> jacexe = makefunction(symb,[x,y], in_place=true) ... julia> a = similar(symb,Float64) 2×2 Matrix{Float64}:  0.0  0.0  0.0  6.93532e-310","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jac_exe([1.0,2.0],a) 2×2 Matrix{Float64}:  -1.68294    0.540302   0.909297  -0.416147","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> a 2×2 Matrix{Float64}:  -1.68294    0.540302   0.909297  -0.416147","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nFor out of place evaluation (matrix created and returned by the executable function) the input vector and return matrix of the executable can be any mix of StaticArray and Vector. If the first argument to `make_function` is a subtype of StaticArray then the compiled executable will return a StaticArray value. The compiled executable can be called with either an `SVector` or `Vector` argument. For small input sizes the `SVector` should be faster, essentially the same as passing the input as scalar values.\n\nFor functions with low input and output dimensions the fastest executable will be generated by calling `make_function` with first argument a subtype of StaticArray and calling the executable with an SVector argument. The usual cautions of StaticArrays apply, that total length of the return value < 100 or so and total length of the input < 100 or so.\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia julia> @variables x y y","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> j = jacobian([x^2 * y^2, cos(x + y), log(x / y)], [x, y])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jexe = makefunction(j, [x, y])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> @assert typeof(j_exe([1.0, 2.0])) <: Array #return type is Array and input type is Vector","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jexe2 = makefunction(SArray{Tuple{3,2}}(j), [x, y])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> @assert typeof(j_exe2(SVector{2}([1.0, 2.0]))) <: StaticArray #return type is StaticArray and input type is SVector. This should be the fastest.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"If you need to generate code that can be cut and pasted into another application then you can use `make_Expr` instead of `make_function`. It has the same arguments except the `in_place` boolean argument is not optional.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia julia> @variables x y y","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> j = jacobian([x^2 * y^2, cos(x + y), log(x / y)], [x, y])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"3×2 Matrix{FastDifferentiation.Node}:  ((y ^ 2) * (2 * x))           ((x ^ 2) * (2 * y))      -(sin((x + y)))               -(sin((x + y)))  ((y / x) * (1 / y))  ((y / x) * -(((x / y) / y)))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"#create code to evaluate the jacobian with in place matrix julia> makeExpr(j,[x,y],true) :((inputvariables, result)->begin           #= c:\\Users\\seatt\\Source\\FastDifferentiation.jl\\src\\CodeGeneration.jl:88 =#           #= c:\\Users\\seatt\\Source\\FastDifferentiation.jl\\src\\CodeGeneration.jl:88 =# @inbounds begin                   #= c:\\Users\\seatt\\Source\\FastDifferentiation.jl\\src\\CodeGeneration.jl:89 =#                   begin                       result .= zero(eltype(inputvariables))                       begin                           var\"##303\" = inputvariables[2] ^ 2                           var\"##304\" = 2 * inputvariables[1]                           var\"##302\" = var\"##303\" * var\"##304\"                           result[CartesianIndex(1, 1)] = var\"##302\"                       end                       begin                           var\"##307\" = inputvariables[1] + inputvariables[2]                           var\"##306\" = sin(var\"##307\")                           var\"##305\" = -var\"##306\"                           result[CartesianIndex(2, 1)] = var\"##305\"                       end                       begin                           var\"##309\" = inputvariables[2] / inputvariables[1]                           var\"##310\" = 1 / inputvariables[2]                           var\"##308\" = var\"##309\" * var\"##310\"                           result[CartesianIndex(3, 1)] = var\"##308\"                       end                       begin                           var\"##312\" = inputvariables[1] ^ 2                           var\"##313\" = 2 * inputvariables[2]                           var\"##311\" = var\"##312\" * var\"##313\"                           result[CartesianIndex(1, 2)] = var\"##311\"                       end                       begin                           result[CartesianIndex(2, 2)] = var\"##305\"                       end                       begin                           var\"##317\" = inputvariables[1] / inputvariables[2]                           var\"##316\" = var\"##317\" / input_variables[2]                           var\"##315\" = -var\"##316\"                           var\"##314\" = var\"##309\" * var\"##315\"                           result[CartesianIndex(3, 2)] = var\"##314\"                       end                   end               end       end)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\n##### Sparse Jacobians and Hessians\nThe functions `sparse_jacobian, sparse_hessian` compute sparse symbolic derivatives. When you pass a sparse symbolic function matrix to `make_function` it will generate an executable which expects an in place sparse matrix to hold the result. For functions with sparse Jacobians or Hessians this can be orders of magnitude faster than using a dense in place matrix.\n","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia julia> hess = sparse_hessian(x^3 + y^3 + z^3, [x,y,z])         3×3 SparseArrays.SparseMatrixCSC{FastDifferentiation.Node, Int64} with 3 stored entries:  (6 * x)        ⋅        ⋅        ⋅  (6 * y)        ⋅        ⋅        ⋅  (6 * z)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> res = similar(hess,Float64) #make sparse matrix with proper sparsity to pass to the generated function 3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 3 stored entries:  0.0   ⋅    ⋅    ⋅   0.0   ⋅   ⋅    ⋅   0.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> spf = makefunction(hess,[x,y,z]) ...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> sp_f([1.0,2.0,3.0],res) 3×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 3 stored entries:  6.0    ⋅     ⋅   ⋅   12.0    ⋅   ⋅     ⋅   18.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"##### Less commonly used functions\nCompute `Hv` without forming the full Hessian matrix. This is useful if the Hessian is very large","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia julia> @variables x y y","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f = x^2 * y^2 ((x ^ 2) * (y ^ 2))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> hvfast, vvec2 = hessiantimesv(f, [x, y]) ...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> hvfastexe = makefunction(hvfast, [[x, y]; vvec2]) #need vvec2 because hvfast is a function of x,y,v1,v2 and have to specify the order of all inputs to the executable ... julia> hvfast_exe([1.0,2.0,3.0,4.0]) #first two vector elements are x,y last two are v1,v2 2-element Vector{Float64}:  56.0  32.0","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nSymbolic and executable Jᵀv and Jv (see this [paper](https://arxiv.org/abs/1812.01892) for applications of this operation).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia julia> (f1,f2) = cos(x)y,sin(y)x ((cos(x) * y), (sin(y) * x))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jv,vvec = jacobiantimesv([f1,f2],[x,y]) ...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jvexe = makefunction(jv,[[x,y];vvec]) ...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jv_exe([1.0,2.0,3.0,4.0]) #first 2 arguments are x,y values and last two are v vector values","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"2×1 Matrix{Float64}:  -2.8876166853748195   1.0633049342884753","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jTv,rvec = jacobiantransposev([f1,f2],[x,y]) ...","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> jtvexe = makefunction(jTv,[[x,y];rvec]) ... julia> jtv_exe([1.0,2.0,3.0,4.0]) 2-element Vector{Float64}:  -1.4116362015446517  -0.04368042858415033","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nConvert between FastDifferentiation and Symbolics representations (requires [FDConversion](https://github.com/brianguenter/FDConversion/tree/main) package, not released yet[^1]):","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia julia> f = x^2+y^2 #Symbolics expression x^2 + y^2","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> Node(f) #convert to FastDifferentiation form x^2 + y^2","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> typeof(ans) Node{SymbolicUtils.BasicSymbolic{Real}, 0}","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> node_exp = x^3/y^4 #FastDifferentiation expression ((x ^ 3) / (y ^ 4))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> tosymbolics(nodeexp) (x^3) / (y^4)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> typeof(ans) Symbolics.Num ```","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"[1]: I am working with the SciML team to see if it is possible to integrate FD differentiation directly into Symbolics.jl.","category":"page"},{"location":"howitworks/#How-it-works","page":"How it works","title":"How it works","text":"","category":"section"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"FD is a domain specific language (DSL) embedded in Julia. FD defines a custom Number type and nd overloads all the mathematical operators in Base to apply to this new number type. You create FD numbers using either @variables or make_variable.","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"Mathematical operations on FD numbers create a graph representing the mathematical expression rather than immediately returning a floating point value. For example, in this code fragment ","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"@variables x y\nf(a,b)= cos(a)*sin(b)\n\nmyexpr = f(x,y)","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"myexpr contains a graph representation of the cos(x)*sin(y) where x,y are FD numbers. ","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"For the most part there is no difference between using FD numbers and the base number types, Float64, Int64, etc. You define your Julia function as you normally world and then call it with FD numbers as inputs; the return value will be a graph representing the expression your Julia function computes.  ","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"The FD differentiation functions, jacobian, hessian, etc., take FD expression graphs as inputs and return FD expression graphs. To turn this into executable Julia code you pass an FD expression graph as an argument to make_function.","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"All the FD differntiation functions use derivative graph factorization[2] to compute derivatives. The FD differentiation algorithm is related to the D* algorithm but is asymptotically faster so it works on much larger expression graphs. The new algorithms used in FD will be described in a soon to be written paper. FD automatic differentiaion is fundamentally different from forward and reverse automatic differentiation. ","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"The efficiency of FD comes from analysis of the graph structure of the function rather than sophisticated algebraic simplification rules. By default FD applies only these algebraic simplications[1] to expressions:","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"x×0=>0\nx×1=>x\nx/1=>x\nx+0=>x\nc₁×c₂=>c₃ for c₁,c₂,c₃ constants\nc₁+c₂=>c₃ for c₁,c₂,c₃ constants\nc₁×(c₂×x) => (c₁×c₂)×x  for c₁,c₂ constants","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"These rules are generally safe in the sense of obeying IEEE floating point arithmetic rules. However if the runtime value of x happens to be NaN or Inf the FD expression x*0 will identically return 0, because it will have been rewritten to 0 by the simplification rules. The expected IEEE result is NaN.","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"[1]: More rules may be added in future versions of FD to improve efficiency.","category":"page"},{"location":"howitworks/","page":"How it works","title":"How it works","text":"[2]: See the D*  paper for an explanation of derivative graph factorization. ","category":"page"},{"location":"limitations/#Limitations","page":"Limitations","title":"Limitations","text":"","category":"section"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"FD does not support expressions with conditionals on FD variables. For example, you can do this:","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"julia> f(a,b,c) = a< 1.0 ? cos(b) : sin(c)\nf (generic function with 2 methods)\n\njulia> f(0.0,x,y)\ncos(x)\n\njulia> f(1.0,x,y)\nsin(y)","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"but you can't do this:","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"julia> f(a,b) = a < b ? cos(a) : sin(b)\nf (generic function with 2 methods)\n\njulia> f(x,y)\nERROR: MethodError: no method matching isless(::FastDifferentiation.Node{Symbol, 0}, ::FastDifferentiation.Node{Symbol, 0})\n\nClosest candidates are:\n  isless(::Any, ::DataValues.DataValue{Union{}})\n   @ DataValues ~/.julia/packages/DataValues/N7oeL/src/scalar/core.jl:291\n  isless(::S, ::DataValues.DataValue{T}) where {S, T}\n   @ DataValues ~/.julia/packages/DataValues/N7oeL/src/scalar/core.jl:285\n  isless(::DataValues.DataValue{Union{}}, ::Any)\n   @ DataValues ~/.julia/packages/DataValues/N7oeL/src/scalar/core.jl:293\n  ...","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"This is because the call f(x,y) creates an expression graph. At graph creation time the FD variables x,y are unevaluated variables with no specific value so they cannot be compared with any other value.","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"The algorithm can be extended to work with conditionals applied to FD variables but the processing time and graph size may grow exponentially with conditional nesting depth. A future version may allow for limited conditional nesting. See Future Work for a potential long term solution to this problem.","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"FD does not support looping internally. All operations with loops, such as matrix vector multiplication, are unrolled into scalar operations. The corresponding executable functions generated by make_function have size proportional to the number of operations. ","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"Expressions with ≈10⁵ scalar operations have reasonable symbolic preprocessing and compilation times.  Beyond this size LLVM compilation time can become extremely long and eventually the executables become so large that their caching behavior is not good and performance declines. ","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"A possible solution to this problem is to do what is called rerolling: detecting repreating indexing patterns in the FD expressions and automatically generating loops to replace inlined code. This rerolling step would be performed on the FD expressions graphs before function compliation.","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"It is not necessary to completely undo the unrolling back to the original expresssion, just to reduce code size enough to get reasonable compilation times and better caching behavior.","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"For example, in this matrix vector multiplication","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"\njulia> a = make_variables(:a,3,3)\n3×3 Matrix{FastDifferentiation.Node}:\n a1_1  a1_2  a1_3\n a2_1  a2_2  a2_3\n a3_1  a3_2  a3_3\n\njulia> b = make_variables(:b,3)\n3-element Vector{FastDifferentiation.Node}:\n b1\n b2\n b3\n\njulia> a*b\n3-element Vector{Any}:\n (((a1_1 * b1) + (a1_2 * b2)) + (a1_3 * b3))\n (((a2_1 * b1) + (a2_2 * b2)) + (a2_3 * b3))\n (((a3_1 * b1) + (a3_2 * b2)) + (a3_3 * b3))","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"the goal is to replace  concrete index numbers with symbolic index variables that represent offsets rather than absolute indices","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"\n[\n  a[i,j]*b[j] + a[i, j+1]*b[j+1] + a[i,j+2]*b[j+2]\n  a[i+1,j]*b[j] + a[i+1, j+1]*b[j+1] + a[i+1,j+2]*b[j+2]\n  a[i+2,j]*b[j] + a[i+2, j+1]*b[j+1] + a[i+2,j+2]*b[j+2]\n]","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"and then to extract looping structure from these indices.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = FastDifferentiation","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Build Status)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FastDifferentiation (FD) is a package for generating efficient executables to evaluate derivatives of Julia functions. It can also generate efficient true symbolic derivatives for symbolic analysis. Unlike forward and reverse mode automatic differentiation FD automatically generates efficient derivatives for arbitrary function types: ℝ¹->ℝ¹, ℝ¹->ℝᵐ, ℝⁿ->ℝ¹, and ℝⁿ->ℝᵐ, m≠1,n≠1. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For f:ℝⁿ->ℝᵐ with n,m large FD may have better performance than conventional AD algorithms because the FD algorithm finds expressions shared between partials and computes them only once. In some cases FD derivatives can be as efficient as manually coded derivatives (see the Lagrangian dynamics example in the D* paper or the Benchmarks section of the documentation for another example).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FD may take much less time to compute symbolic derivatives than Symbolics.jl even in the ℝ¹->ℝ¹ case. The executables generated by FD may also be much faster (see Symbolic Processing[1]. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You should consider using FastDifferentiation when you need: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"a fast executable for evaluating the derivative of a function and the overhead of the preprocessing/compilation time is swamped by evaluation time.\nto do additional symbolic processing on your derivative. FD can generate a true symbolic derivative to be processed further in Symbolics.jl or another computer algebra system.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the FD feature set:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":" Dense Jacobian Sparse Jacobian Dense Hessian Sparse Hessian Higher order derivatives Jᵀv Hv\nCompiled function ✅ ✅ ✅ ✅ ✅ ✅ ✅\nSymbolic expression ✅ ✅ ✅ ✅ ✅ ✅ ✅","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Jᵀv and Jv compute the Jacobian transpose times a vector and the Jacobian times a vector, without explicitly forming the Jacobian matrix. For applications see this paper. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Hv computes the Hessian times a vector without explicitly forming the Hessian matrix. This can be useful when the Hessian matrix is large and sparse.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you use FD in your work please share the functions you differentiate with me. I'll add them to the benchmarks. The more functions available to test the easier it is for others to determine if FD will help with their problem.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is beta software being modified on a daily basis. Expect bugs and frequent, possibly breaking changes, over the next month or so. Documentation is frequently updated so check the latest docs before filing an issue. Your problem may have been fixed and documented.","category":"page"},{"location":"#Notes-about-special-derivatives","page":"Introduction","title":"Notes about special derivatives","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The derivative of |u| is u/|u| which is NaN when u==0. This is not a bug. The derivative of the absolute value function is undefined at 0 and the way FD signals this is by returning NaN.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: I am working with the SciML team to see if it is possible to integrate FD differentiation directly into Symbolics.jl.","category":"page"}]
}
